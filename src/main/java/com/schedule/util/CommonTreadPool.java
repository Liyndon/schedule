package com.schedule.util;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * Created by fengwei.cfw on 2017/2/9. */public class CommonTreadPool {    /**     1、如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。     2、如果此时线程池中的数量等于 corePoolSize，但是缓冲队列 workQueue未满，那么任务被放入缓冲队列。     3、如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。     4、如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过handler所指定的策略来处理此任务。     也就是：处理任务的优先级为：核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。     5、当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。     */    //线程池维护线程的最少数量    private final static int corePoolSize = 100;    //线程池维护线程的最大数量    private final static int maximumPoolSize = 1000;    //线程池维护线程所允许的空闲时间    private final static long keepAliveTime = 10;    //允许等待的队列大小    private final static int capacity = 10000;    private static volatile ThreadPoolExecutor executor = null;    private final static Logger logger = LoggerFactory.getLogger(CommonTreadPool.class);    public static ThreadPoolExecutor getInstance(String why){        logger.debug(String.format("正在申请线程[%s]",why));        if(executor == null){            synchronized (ThreadPoolExecutor.class){                if(executor == null){                    executor = new ThreadPoolExecutor(corePoolSize,                            maximumPoolSize, keepAliveTime, TimeUnit.MINUTES,                            new ArrayBlockingQueue<Runnable>(capacity));                }            }        }        return executor;    }}